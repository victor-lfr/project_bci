#pragma once

// Definition of the communication with the wheel server on the koala
// This provides access to read the current wheel speed, position and IR sensors

#include <ktprot.h>
#include <array>
#include <fstream>
#include <boost/asio.hpp>


namespace kteams {
  namespace koala {
    // The IR and the wheels are accessed through the wheel server
    // and the communication is handled by ktprot
    struct WheelServer {
    
      ktprot::Writer writer;
      ktprot::Reader reader;
      boost::asio::ip::tcp::iostream socket;
      std::ofstream log_input_wheels;
      std::ofstream log_output_wheels;

      WheelServer();
      void connect(std::string hostname, std::string port);
      void close();
    };
  

    ////////////////////////////////////////////////// Infrared
  
    // // The positions of the sensors, relative to the base_link, in m 
    // double ir_sensors_translation [3*NB_IR_SENSORS] = { -130.0,   40.0, 0.0, // L7
    // 						      -130.0,  130.0, 0.0, // L6
    // 						      -42.5,  130.0, 0.0, // L5 
    // 						      42.5,  130.0, 0.0, // L4
    // 						      134.5,  126.0, 0.0, // L3
    // 						      170.0,   71.0, 0.0, // L2
    // 						      170.0,   43.0, 0.0, // L1
    // 						      170.0,   15.0, 0.0, // L0
    // 						      170.0,  -15.0, 0.0, // R0
    // 						      170.0,  -43.0, 0.0, // R1
    // 						      170.0,  -71.0, 0.0, // R2
    // 						      134.5, -126.0, 0.0, // R3
    // 						      42.5, -130.0, 0.0, // R4
    // 						      -42.5, -130.0, 0.0, // R5
    // 						      -130.0, -130.0, 0.0, // R6
    // 						      -130.0,  -40.0, 0.0}; // R7

    // // The orientation of the sensors, relative to the base_link, in degrees
    // // and relative to the x-axis
    // double ir_sensors_rotation [NB_IR_SENSORS] = { 180.0,   // L7
    // 						 135.0,   // L6
    // 						 90.0,    // L5
    // 						 90.0,    // L4
    // 						 45.0,    // L3
    // 						 30.0,    // L2
    // 						 10.0,    // L1
    // 						 0.0,     // L0
    // 						 0.0,     // R0
    // 						 -10.0,    // R1
    // 						 -30.0,    // R2
    // 						 -45.0,    // R3
    // 						 -90.0,    // R4
    // 						 -90.0,    // R5
    // 						 -135.0,   // R6
    // 						 -180.0 }; // R7

 
    // The IRReader is calibrated by matching the response curves
    // of the documentation with the curve generated by
    // koala_driver/scripts/calibrate_ir.py
    struct IRReader {
      static constexpr double ir_min_dist = 0.050; // m
      static constexpr double ir_max_dist = 0.250; // m
      static constexpr double ir_half_dist = 0.075; // m
      static constexpr int ir_order = 5; // order of the polynom for regressing the IR responses
      static constexpr int max_ir_value = 1023;
      static constexpr int nb_ir_sensors = 16;

      WheelServer& server;
      IRReader(WheelServer& serv);

      // The returned distance is in m.
      static double get_dist_from_ir(int ir_value);
      void read(std::array<double, nb_ir_sensors>& ranges, std::array<int, nb_ir_sensors>& raw);
    };


    ////////////////////////////////////////////////// Wheels

    // The inter_wheels_distance was actually measured and then hand-tuned
    // I don't know why but I had to increase it slightly, otherwise getting some offsets in the computed 
    // odometry
    // To set them up, I actually run the koala, and look with rviz at the base_link relative to odom
    // frames. I make a forward walk for covering 1m in rviz and measure the real distance done by the robot
    // to correct FACTOR_PULSE_TO_SPEED
    // Then I do a complete turn to correct INTER_WHEELS_DISTANCE
    struct WheelSpeed {
      static constexpr double factor_pulse_to_speed = (4.25*1e-3);
      static constexpr double inter_wheels_distance = 0.305; // m
      WheelServer& server;
      WheelSpeed(WheelServer& serv);
      void read(double& linear, double& angular) const;
      void write(double linear, double angular) const;
    };
  }
}
